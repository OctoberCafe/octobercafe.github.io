<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>Spring初识 | OctoberCafe&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    
      <link rel="icon" href="/favicon.png">
    

    <link rel="stylesheet" href="/css/style.css">

    <link rel="stylesheet" href="/js/google-code-prettify/tomorrow-night-eighties.min.css">

  </head>

  <body>

<header>
	<a id="logo" href="/" title="OctoberCafe&#39;s Blog">
	<img src="/favicon.png" alt="OctoberCafe&#39;s Blog"></a>
	
	
		<!--搜索栏-->
		<i class="js-toggle-search iconfont icon-search"></i>


<form class="js-search search-form search-form--modal" method="get" action="http://gushi.li" role="search">
	<div class="search-form__inner">
		<div>
			<i class="iconfont icon-search"></i>
			<input class="text-input" placeholder="Enter Key..." type="search">
		</div>
	</div>
</form>
	

	
		<!--侧边导航栏-->
		<a id="nav-toggle" href="#"><span></span></a>

<nav>
	<div class="menu-top-container">
		<ul id="menu-top" class="menu">
			
				
				<li class="current-menu-item">
					<a href="http://weibo.com/OctoberCafe/" target="_blank">Weibo</a>
				</li>
			
		</ul>
	</div>
</nav>
	

</header>
<div class="m-header ">
	<section id="hero1" class="hero">
		<div class="inner">
		</div>
	</section>
	
		<figure class="top-image" data-enable=true></figure>
	
</div>

<!--文章列表-->
<div class="wrapper">
  
    <!--文章-->
<article>
	
  
    <h1 class="post-title" itemprop="name">
      Spring初识
    </h1>
  

	<div class='post-body mb'>
		<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="IOC-依赖注入（控制翻转）"><a href="#IOC-依赖注入（控制翻转）" class="headerlink" title="IOC:依赖注入（控制翻转）"></a>IOC:依赖注入（控制翻转）</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="1-导入Jar包"><a href="#1-导入Jar包" class="headerlink" title="1. 导入Jar包"></a>1. 导入Jar包</h4><h4 id="2-创建类进行注入"><a href="#2-创建类进行注入" class="headerlink" title="2. 创建类进行注入"></a>2. 创建类进行注入</h4><h4 id="3-创建xx-xml文件"><a href="#3-创建xx-xml文件" class="headerlink" title="3. 创建xx.xml文件"></a>3. 创建xx.xml文件</h4><h4 id="4-可以读取配置文件获取到实体对象"><a href="#4-可以读取配置文件获取到实体对象" class="headerlink" title="4. 可以读取配置文件获取到实体对象"></a>4. 可以读取配置文件获取到实体对象</h4><pre><code>ApplicationContext ac = 
new ClassPathXmlApplicationContext(&quot;spring-service.xml&quot;);
</code></pre><h3 id="ioc中的实体对象获取"><a href="#ioc中的实体对象获取" class="headerlink" title="ioc中的实体对象获取"></a>ioc中的实体对象获取</h3><h4 id="1-通过new对象相互调用-Dao-service-action-serviced的方式"><a href="#1-通过new对象相互调用-Dao-service-action-serviced的方式" class="headerlink" title="1.通过new对象相互调用(Dao service action serviced的方式)"></a>1.通过new对象相互调用(Dao service action serviced的方式)</h4><pre><code> * Student student =new Student();

student.setName(&quot;zhangsan&quot;);
student.setTeacher(new Teacher(&quot;jack&quot;));

System.out.println(student+&quot; &quot;+student.getName()+&quot; &quot;+student.getTeacher());*/
</code></pre><h4 id="2-使用spring-xml文件中则可以实现直接进行调用-实体类的属性必须写set方法"><a href="#2-使用spring-xml文件中则可以实现直接进行调用-实体类的属性必须写set方法" class="headerlink" title="2.使用spring.xml文件中则可以实现直接进行调用(实体类的属性必须写set方法)"></a>2.使用spring.xml文件中则可以实现直接进行调用(实体类的属性必须写set方法)</h4><pre><code>&lt;bean name=&quot;tea&quot; class=&quot;com.briup.ioc.Teacher&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;jack&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean name=&quot;stu&quot; class=&quot;com.briup.ioc.Student&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;teacher&quot; ref=&quot;tea&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
</code></pre><h5 id="student类中name属性的student的set方法"><a href="#student类中name属性的student的set方法" class="headerlink" title="student类中name属性的student的set方法"></a>student类中name属性的student的set方法</h5><pre><code>public void setName(String name) {
    this.name = name;
}
</code></pre><h5 id="进行测试"><a href="#进行测试" class="headerlink" title="进行测试"></a>进行测试</h5><pre><code>ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-service.xml&quot;);
    Student student = (Student) ac.getBean(&quot;stu&quot;);
    Teacher teacher = student.getTeacher();
    /*System.out.println(student +&quot; &quot;+student.getName());
    System.out.println(teacher+&quot; &quot;+teacher.getName());
</code></pre><h5 id="在这里必须将之前的xml进行配置的部分删除掉，更换成"><a href="#在这里必须将之前的xml进行配置的部分删除掉，更换成" class="headerlink" title="在这里必须将之前的xml进行配置的部分删除掉，更换成"></a>在这里必须将之前的xml进行配置的部分删除掉，更换成</h5><pre><code>&lt;context:component-scan base-package=&quot;com.briup.ioc&quot; /&gt;
    &lt;!--这里的com.briup.ioc是包名--&gt;
</code></pre><h4 id="3-用-Component和-Autowired进行注解"><a href="#3-用-Component和-Autowired进行注解" class="headerlink" title="3. 用@Component和@Autowired进行注解"></a>3. 用@Component和@Autowired进行注解</h4><pre><code>@Component(&quot;stu&quot;)
public class Student {
private String name;
@Autowired
private Teacher teacher;

public Student() {

}
</code></pre><h5 id="可以将-Component更换成-Repository、-Serviceh或者-Controller-Autowired可以更换成-Resource，但是在调用的时候必须写成小写不能修成别名"><a href="#可以将-Component更换成-Repository、-Serviceh或者-Controller-Autowired可以更换成-Resource，但是在调用的时候必须写成小写不能修成别名" class="headerlink" title="可以将@Component更换成@Repository、@Serviceh或者@Controller;@Autowired可以更换成@Resource，但是在调用的时候必须写成小写不能修成别名"></a>可以将@Component更换成@Repository、@Serviceh或者@Controller;@Autowired可以更换成@Resource，但是在调用的时候必须写成小写不能修成别名</h5><pre><code>Student student = (Student) ac.getBean(&quot;student&quot;);
//这里的student对应Student的类   不能换成其他的名称或者实例化的对象
</code></pre><h3 id="ioc中的annotation配置"><a href="#ioc中的annotation配置" class="headerlink" title="ioc中的annotation配置"></a>ioc中的annotation配置</h3><p>  <strong>@Autowired</strong></p>
<ol>
<li>@Autowired默认按照byType匹配的方式进行注入,如果没有一个bean的类型是匹配的则会抛异常,如果有多个bean的类型都匹配成功了,那么再按byName方式进行选择</li>
<li>@Autowired注解可以写在成员变量、setter方法、构造器函数上面</li>
<li>@Autowired如果最终匹配不成功(注意一定是一个都没有找到的情况)则会抛出异常,但是如果设置为 @Autowired(required=false),则最终匹配不成功没有不会抛出异常。</li>
<li>@Autowired可以结合 @Qualifier(“beanName”)来使用,则可以达到byName的效果</li>
<li>@Autowired使用后需要在xml文件加入以下配置才能生效:<context:annotation-config>   </context:annotation-config></li>
</ol>
<p><strong>@Resource</strong></p>
<ol>
<li><p>@Resource的作用和@Autowired差不多,只不过 @Resource是默认先用byName,如果找不到合适的就再用byType来注入</p>
</li>
<li><p>@Resource有俩个属性,name和type,使用name属性则表示要byName匹配,使用type属性则表示要byType匹配</p>
</li>
<li><p>@Resource使用后需要在xml文件加入以下配置才能生效:</p>
  <context:annotation-config> 

</context:annotation-config></li>
</ol>
<p><strong>@PostConstruct 和 @PreDestroy</strong></p>
<ol>
<li>标注了@PostConstruct注释的方法将在类实例化后调用。</li>
<li>标注了 @PreDestroy的方法将在类销毁之前调用。</li>
</ol>
<p><strong>@Component</strong></p>
<ol>
<li><p>@Component注解可以直接定义bean，而无需在xml定义。但是若两种定义同时存在，xml中的定义会覆盖类中注解的Bean定义。</p>
</li>
<li><p>@Component注解直接写在类上面即可</p>
</li>
<li><p>@Component有一个可选的参数，用于指定 bean 的名称: @Component(“boss”)</p>
</li>
<li><p>@Component容易不指定参数，则 bean 的名称为当前类的类名小写</p>
</li>
<li><p>@Component使用之后需要在xml文件配置一个标签:<br> <code>&lt;context:component-scan/&gt;</code></p>
</li>
<li><p>xml的context标签<br> <code>&lt;context:component-scan base-package=&quot;com.briup.ioc.annotation&quot; /&gt;</code><br> 可以表示spring需要检查哪个包下的java类,看它们是否使用了 @Component注解</p>
</li>
<li><p>@Component定义的bean默认情况下都是单例模式的,如果要让这个bean变为非单例,可以再结合这个 @Scope 注解来达到目标 @Scope(“prototype”)</p>
</li>
<li><p>@Component是Spring中所有bean组件的通用形式, @Repository @Service @Controller 则是 @Component的细化,用来表示更具体的用例，分别对应了持久化层、服务层和表现层。但是至少到现在为止这个四种注解的实质区别很小(甚至几乎没有),都是把当前类注册为spring容器中的一个bean</p>
</li>
</ol>
<p><strong>注意</strong></p>
<p>component-scan标签默认情况下自动扫描指定路径下的包（含所有子包），将带有@Component @Repository、@Service、@Controller标签的类自动注册到spring容器。对标记了Spring中的@Required、@Autowired、@PostConstruct、@PreDestroy、@Resource、@WebServiceRef、@EJB、@PersistenceContext、@PersistenceUnit等注解的类进行对应的操作使注解生效（包含了annotation-config标签的作用）</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><h5 id="Spring-Service-xml"><a href="#Spring-Service-xml" class="headerlink" title="Spring-Service.xml"></a>Spring-Service.xml</h5><pre><code>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; 
    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;
     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
     http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
     http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
     http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&gt;
     &lt;context:component-scan base-package=&quot;com.briup.ioc&quot; /&gt;

     &lt;bean name=&quot;tea&quot; class=&quot;com.briup.ioc.Teacher&quot;&gt;
     &lt;property name=&quot;name&quot; value=&quot;jack&quot;&gt;&lt;/property&gt;
     &lt;/bean&gt;
     &lt;bean name=&quot;stu&quot; class=&quot;com.briup.ioc.Student&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;teacher&quot; ref=&quot;tea&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
        &lt;/beans&gt;
</code></pre><h5 id="Student-java"><a href="#Student-java" class="headerlink" title="Student.java"></a>Student.java</h5><pre><code>package com.briup.ioc;
import javax.annotation.Resource;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Controller;
import org.springframework.stereotype.Repository;
import org.springframework.stereotype.Service;

//@Component
//@Repository
@Service
//@Controller
public class Student {
    private String name;
//@Autowired
    @Resource
    private Teacher teacher;
    public Student() {
    }
    public Student(String name) {
        super();
        this.name = name;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Teacher getTeacher() {
        return teacher;
    }
    public void setTeacher(Teacher teacher) {
        this.teacher = teacher;
    }
}
</code></pre><h5 id="Teacher-java"><a href="#Teacher-java" class="headerlink" title="Teacher.java"></a>Teacher.java</h5><pre><code>package com.briup.ioc;
import org.springframework.stereotype.Component;
@Component
public class Teacher {

    private String name;
    private Teacher teacher;

    public Teacher() {
    }

    public Teacher(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Teacher getTeacher() {
        return teacher;
    }

    public void setTeacher(Teacher teacher) {
        this.teacher = teacher;
    }

}
</code></pre><h5 id="IOCTest-java"><a href="#IOCTest-java" class="headerlink" title="IOCTest.java"></a>IOCTest.java</h5><pre><code>package com.briup.ioc;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class IOCTest {

    public static void main(String[] args) {
        /*  实例化对象获取实例的方法
         * Student stu =new Student();
        stu.setName(&quot;zhangsan&quot;);
        stu.setTeacher(new Teacher(&quot;jack&quot;));

        System.out.println(student+&quot; &quot;+student.getName()+&quot; &quot;+student.getTeacher());
        */

        //读取Spring-Service.xml文件
        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-service.xml&quot;);

        Student student = (Student) ac.getBean(&quot;student&quot;);
        Teacher teacher = student.getTeacher();

        /*System.out.println(student +&quot; &quot;+student.getName());
        System.out.println(teacher+&quot; &quot;+teacher.getName());
        */
        System.out.println(student+&quot;   &quot;+teacher);
    }
}
</code></pre><hr>
<h2 id="AOP面向切面的编程"><a href="#AOP面向切面的编程" class="headerlink" title="AOP面向切面的编程"></a>AOP面向切面的编程</h2><ul>
<li>几个概念名词：切面 、切入点、连接点、织入、目标对象、代理对象</li>
</ul>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><ul>
<li><p>代理模式是常用的Java设计模式，它的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。</p>
</li>
<li><p>代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。</p>
</li>
<li><p><strong>注意</strong><br>委托类对象就是我们后面说到的 目标对象(需要【被】代理的对象)<br>代理类对象就是我们后面说到的 代理对象(目标对象就是需要这个对象做为代理)</p>
</li>
</ul>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul>
<li>与静态代理类对照的是动态代理类，动态代理类的字节码在程序运行时由Java反射机制动态生成，无需程序员手工编写它的源代码。动态代理类不仅简化了编程工作，而且提高了软件系统的可扩展性，因为Java反射机制可以生成任意类型的动态代理类。java.lang.reflect 包下面的Proxy类和InvocationHandler 接口提供了生成动态代理类的能力。\</li>
</ul>
<p><strong><em>例子</em></strong></p>
<h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><pre><code>   public interface IStudentService{

    void save(Student s);

    void delete(long id);

    Student find(long id);    
}
</code></pre><h5 id="日志类"><a href="#日志类" class="headerlink" title="日志类"></a>日志类</h5><pre><code>public class StudentLogger {

   public void log(String msg){
       System.out.println(&quot;log: &quot;+msg);
   }

  }
</code></pre><h5 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h5><pre><code>public class StudentServiceImpl implements IStudentService {
 public void delete(long id) {
     // 记录日志
     System.out.println(&quot;student is deleted...&quot;);
 }

 public Student find(long id) {
     // 记录日志
     System.out.println(&quot;student is found...&quot;);
     return null;
 }

 public void save(Student s) {
     // 记录日志
     System.out.println(&quot;student is saved...&quot;);
 }
}

//InvocationHandler接口的实现类,java的动态代理中需要使用
public class MyHandler implements InvocationHandler {
 //目标对象
 private Object target; 
 private StudentLogger logger = new StudentLogger();

 public MyHandler() {
 }

 public MyHandler(Object target) {
     this.target = target;
 }

 // 参数1 将来所产生的代理对象 Proxy4$
 // 参数2 将来需要调用到的目标对象里面真正的那个方法的镜像
 // 参数3 将来调用方法的时候所传的参数
 public Object invoke(Object proxy, Method m, Object[] args)
         throws Throwable {
     // 获得将来所调用方法的名字
     String methodName = m.getName();
     // 用日志记录输出一下
     logger.log(methodName + &quot; is invoked...&quot;);
     // 用反射的方式去调用将来需要真正调用的方法.
     Object o = m.invoke(target, args);

     return o;
 }
 get/set
 ....
}
</code></pre><h5 id="main测试类"><a href="#main测试类" class="headerlink" title="main测试类"></a>main测试类</h5><pre><code>//目标对象
IStudentService service = new StudentServiceImpl();
//service是我们的目标对象。
//我们要给目标对象产生代理对象。
//目标对象service只能单独执行delete方法。
//但是我们需要的是:先执行log日志方法再执行delete方法。
//目标对象service做不到这个要求,所以我们要给目标对象service
//生成一个代理对象去完成这俩个操作.


//怎么给目标对象生成代理对象:
//JDK动态代理的方式

//获得目标对象的Class对象
Class c = service.getClass();
//获得目标对象的类加载器对象
ClassLoader classLoader = c.getClassLoader();

//获得目标对象所实现的所有接口
Class[] interfaces = c.getInterfaces();

//获得一个InvocationHandler接口的实现类对象,并把目标对象传进去
InvocationHandler h = 
        new MyHandler(service);

//参数1 目标对象的类加载器对象
//参数2 目标对象所实现的所有接口. Class类型数组
//参数3 InvocationHandler接口的实现类对象
IStudentService proxy = 
    (IStudentService)Proxy.newProxyInstance
    (classLoader, interfaces, h);
//这里的proxy是一个实现了IStudentService接口动态生成的代理类的对象
proxy.delete();
</code></pre><h3 id="完整测试代码"><a href="#完整测试代码" class="headerlink" title="完整测试代码"></a>完整测试代码</h3><h4 id="IStudentService-java"><a href="#IStudentService-java" class="headerlink" title="IStudentService.java"></a>IStudentService.java</h4><pre><code>package com.briup.aop;

public interface IStudentService {
     void save();

    void delete(long id);

}
</code></pre><h3 id="动态代理-1"><a href="#动态代理-1" class="headerlink" title="动态代理"></a>动态代理</h3><h5 id="AroundAdvice-java"><a href="#AroundAdvice-java" class="headerlink" title="AroundAdvice.java"></a>AroundAdvice.java</h5><pre><code>package com.briup.aop.around;

import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
import org.xml.sax.SAXException;

import com.sun.xml.internal.bind.v2.runtime.unmarshaller.UnmarshallingContext.State;

public class AroundAdvice implements MethodInterceptor{

    private MyLogger logger;

    public Object invoke(MethodInvocation mi) throws Throwable {
        // mi.getMethod()获得将来要调用的方法的镜像
        //在目标方法执行之前做日志
        logger.log(mi.getMethod().getName() + &quot; is start...&quot;);

        // 这个方法就是用来调用目标对象中的方法的
        Object returnValue = mi.proceed();

        //在目标方法执行之后做日志
        logger.log(mi.getMethod().getName() + &quot; is end...&quot;);

        return returnValue;
    }



    public MyLogger getLogger() {
        return logger;
    }

    public void setLogger(MyLogger logger) {
        this.logger = logger;
    }

}
</code></pre><h5 id="MyLogger-java"><a href="#MyLogger-java" class="headerlink" title="MyLogger.java"></a>MyLogger.java</h5><pre><code>package com.briup.aop.around;
//日志类
public class MyLogger {
    public void log(String msg){
        System.out.println(&quot;log:&quot;+msg);
    }
}
</code></pre><h5 id="UserService"><a href="#UserService" class="headerlink" title="UserService"></a>UserService</h5><pre><code>package com.briup.aop.around;
public interface UserService {
        void save();
}
</code></pre><h5 id="UserServiceImpl-java"><a href="#UserServiceImpl-java" class="headerlink" title="UserServiceImpl.java"></a>UserServiceImpl.java</h5><pre><code>package com.briup.aop.around;

public class UserServiceImpl implements UserService{

    @Override
    public void save() {
        // TODO Auto-generated method stub
        System.out.println(&quot;in userService save..&quot;);
    }
}
</code></pre><h5 id="AOPTest-java"><a href="#AOPTest-java" class="headerlink" title="AOPTest.java"></a>AOPTest.java</h5><pre><code>package com.briup.aop.around;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class AOPTest {
    public static void main(String[] args) {

        System.out.println(&quot;aop.around running.....&quot;);
ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-service.xml&quot;);

//获取代理对象
    UserService service =(UserService) ac.getBean(&quot;proxy&quot;);
        service.save();
}
}
</code></pre><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><h5 id="MyHandler-java"><a href="#MyHandler-java" class="headerlink" title="MyHandler.java"></a>MyHandler.java</h5><pre><code>package com.briup.aop.jdk;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class MyHandler  implements InvocationHandler{
    //目标对象
        private Object target; 
        private StudentLogger logger = new StudentLogger();

        public MyHandler() {
        }

        public MyHandler(Object target) {
            this.target = target;
        }

        // 参数1 将来所产生的代理对象 Proxy4$
        // 参数2 将来需要调用到的目标对象里面真正的那个方法的镜像
        // 参数3 将来调用方法的时候所传的参数
        public Object invoke(Object proxy, Method m, Object[] args)
                throws Throwable {
            // 获得将来所调用方法的名字
            String methodName = m.getName();
            // 用日志记录输出一下
            logger.log(methodName + &quot; is invoked...&quot;);
            // 用反射的方式去调用将来需要真正调用的方法.
            Object o = m.invoke(target, args);

            return o;
        }

        public Object getTarget() {
            return target;
        }

        public void setTarget(Object target) {
            this.target = target;
        }
}
</code></pre><h5 id="StudentLogger-java"><a href="#StudentLogger-java" class="headerlink" title="StudentLogger.java"></a>StudentLogger.java</h5><pre><code>package com.briup.aop.jdk;

public class StudentLogger {

    public void log(String msg){
        System.out.println(&quot;log: &quot;+msg);
    }
}
</code></pre><h5 id="StudentServiceImpl-java"><a href="#StudentServiceImpl-java" class="headerlink" title="StudentServiceImpl.java"></a>StudentServiceImpl.java</h5><pre><code>package com.briup.aop.jdk;
import com.briup.aop.IStudentService;
public class StudentServiceImpl implements IStudentService{

    @Override
    public void save() {
        // TODO Auto-generated method stub

        System.out.println(&quot;in  save...&quot;);

    }

    @Override
    public void delete(long id) {
        // TODO Auto-generated method stub
        System.out.println(&quot;in deleting...&quot;);
    }
}
</code></pre><hr>
<h4 id="spring的作用"><a href="#spring的作用" class="headerlink" title="spring的作用"></a>spring的作用</h4><ul>
<li>不用new Dao层的对象,直接将dao层对象注入service层,通过读取spring-service.xml文件便可读取实体对象。</li>
</ul>
<h4 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><ul>
<li><p>String Struts Hibernae的结合</p>
</li>
<li><p>分别对应action/servlet层、serivce 层和 dao 层</p>
</li>
<li><p>配置struts2的核心部分是添加过滤器</p>
</li>
</ul>

	</div>
	<div class="meta split">
		
			<span>本文总阅读量 <span id="busuanzi_value_page_pv"></span> 次</span>
		
		<time class="post-date" datetime="2017-08-30T02:49:15.000Z" itemprop="datePublished">2017-08-30</time>
	</div>
</article>

<!--评论-->

	
<div class="ds-thread" data-thread-key="Spring初识" data-title="Spring初识" data-url="http://yoursite.com/2017/08/30/Spring初识/"></div>
<script type="text/javascript">

var duoshuoQuery = {short_name:"yumemor"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0]
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
</script>


  
</div>


  <svg id="bigTriangleColor" width="100%" height="40" viewBox="0 0 100 102" preserveAspectRatio="none">
    <path d="M0 0 L50 100 L100 0 Z"></path>
  </svg>

  


  <div class="wrapper"></div>





<div class="fat-footer">
	<div class="wrapper">
		<div class="layout layout--center">
			<div class="layout__item palm-mb">
				<div class="media">
					<img class="headimg" src='http://oct8d1mqf.bkt.clouddn.com/2016-10-17-15%3A42%3A28.jpg' alt='OctoberCafe'>
					<div class="media__body">
						<h4>OctoberCafe&#39;s Blog</h4>
						<p class='site-description'></p>
					</div>
				</div>
				<div class="author-contact">
					<ul>
						
							
							<li>
				        		<a href="http://weibo.com/OctoberCafe/" target="_blank">
				        			
				        				<i class="iconfont icon-weibo"></i>
				        			
				        		</a>
				        	</li>
						
							
							<li>
				        		<a href="https://github.com/OctoberCafe" target="_blank">
				        			
				        				<i class="iconfont icon-github"></i>
				        			
				        		</a>
				        	</li>
						
					</ul>
				</div>
			</div>
		</div>
	</div>
</div>

<footer class="footer" role="contentinfo">
	<div class="wrapper wrapper--wide split split--responsive">
		
			<span>本站总访问量 <span id="busuanzi_value_site_pv"></span> 次, 访客数 <span id="busuanzi_value_site_uv"></span> 人次</span>
		
		<span>Theme by <a href="http://github.com/yumemor">Yumemor</a>. Powered by <a href="http://hexo.io">Hexo</a></span>
	</div>
</footer>

	<!-－这里导入了 lib.js 里面涵盖了 jQuery 等框架 所以注释掉-->
	<!--<script src="http://lib.sinaapp.com/js/jquery/2.0/jquery.min.js"></script>-->
	<script src="/js/lib.js"></script>
	<script src="/js/google-code-prettify/prettify.js"></script>
	<script src="/js/module.js"></script>
	<script src="/js/script.js"></script>
	
		<script async src="http://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	
	<script type='text/javascript'>
		//代码高亮
		$(document).ready(function(){
	 		$('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
   			prettyPrint();
		});
	</script>
	</body>
</html>
